#include<stdio.h>

char    buffer_programa[400][80];
struct  nemonicos
{
	 char    *nemonico;
	 char    relativo;
	 char    inherente;
	 char    inmediato;
	 char    indexado;
	 char    extendido;
}opcode[119]      ={
							  {"ABA ",0x00,0x1b,0x00,0x00,0x00},
							  {"ABX ",0x00,0x3a,0x00,0x00,0x00},
							  {"ADCA ",0x00,0x00,0x89,0xa9,0xb9},
							  {"ADCB ",0x00,0x00,0xc9,0xe9,0xf9},
							  {"ADDA ",0x00,0x00,0x8b,0xab,0xbb},
							  {"ADDB ",0x00,0x00,0xcb,0xeb,0xfb},
							  {"ASL ",0x00,0x00,0x00,0x68,0x78},
							  {"ASLA ",0x00,0x48,0x00,0x00,0x00},
							  {"ASLB ",0x00,0x58,0x00,0x00,0x00},
							  {"ASLD ",0x00,0x05,0x00,0x00,0x00},
							  {"ASR ",0x00,0x00,0x00,0x67,0x77},
							  {"ASRA ",0x00,0x47,0x00,0x00,0x00},
							  {"ASRB ",0x00,0x57,0x00,0x00,0x00},
							  {"BITA ",0x00,0x00,0x85,0xa5,0xb5},
							  {"BITB ",0x00,0x00,0xc5,0xe5,0xf5},
							  {"BRA ",0x20,0x00,0x00,0x00,0x00},
							  {"BRN ",0x21,0x00,0x00,0x00,0x00},
							  {"BCC ",0x24,0x00,0x00,0x00,0x00},
							  {"BCS ",0x25,0x00,0x00,0x00,0x00},
							  {"BEQ ",0x27,0x00,0x00,0x00,0x00},
							  {"BGE ",0x2c,0x00,0x00,0x00,0x00},
							  {"BGT ",0x2e,0x00,0x00,0x00,0x00},
							  {"BHI ",0x22,0x00,0x00,0x00,0x00},
							  {"BHS ",0x24,0x00,0x00,0x00,0x00},
							  {"BLE ",0x2f,0x00,0x00,0x00,0x00},
							  {"BLO ",0x25,0x00,0x00,0x00,0x00},
							  {"BLS ",0x23,0x00,0x00,0x00,0x00},
							  {"BLT ",0x2d,0x00,0x00,0x00,0x00},
							  {"BMI ",0x2b,0x00,0x00,0x00,0x00},
							  {"BNE ",0x26,0x00,0x00,0x00,0x00},
							  {"BVC ",0x28,0x00,0x00,0x00,0x00},
							  {"BVS ",0x29,0x00,0x00,0x00,0x00},
							  {"BPL ",0x2a,0x00,0x00,0x00,0x00},
							  {"BSR ",0x8d,0x00,0x00,0x00,0x00},
							  {"CPX ",0x00,0x00,0x8c,0xac,0xbc},
							  {"CLR ",0x00,0x00,0x00,0x6f,0x7f},
							  {"CLRA ",0x00,0x4f,0x00,0x00,0x00},
							  {"CLRB ",0x00,0x5f,0x00,0x00,0x00},
							  {"CLC ",0x00,0x0c,0x00,0x00,0x00},
							  {"CLI ",0x00,0x0e,0x00,0x00,0x00},
							  {"CLV ",0x00,0x0a,0x00,0x00,0x00},
							  {"CMPA ",0x00,0x00,0x81,0xa1,0xb1},
							  {"CMPB ",0x00,0x00,0xc1,0xe1,0xf1},
							  {"COM ",0x00,0x00,0x00,0x63,0x73},
							  {"COMA ",0x00,0x43,0x00,0x00,0x00},
							  {"COMB ",0x00,0x53,0x00,0x00,0x00},
							  {"DEX ",0x00,0x09,0x00,0x00,0x00},
							  {"DES ",0x00,0x34,0x00,0x00,0x00},
							  {"DAA ",0x00,0x19,0x00,0x00,0x00},
							  {"DEC ",0x00,0x00,0x00,0x6a,0x7a},
							  {"DECA ",0x00,0x4a,0x00,0x00,0x00},
							  {"DECB ",0x00,0x5a,0x00,0x00,0x00},
							  {"EORA ",0x00,0x00,0x88,0xa8,0xb8},
							  {"EORB ",0x00,0x00,0xc8,0xe8,0xf8},
							  {"INX ",0x00,0x08,0x00,0x00,0x00},
							  {"INS ",0x00,0x31,0x00,0x00,0x00},
							  {"INC ",0x00,0x00,0x00,0x6c,0x7c},
							  {"INCA ",0x00,0x4c,0x00,0x00,0x00},
							  {"INCB ",0x00,0x5c,0x00,0x00,0x00},
							  {"JMP ",0x00,0x00,0x00,0x6e,0x7e},
							  {"JSR ",0x00,0x00,0x00,0xad,0xbd},
							  {"MUL ",0x00,0x3d,0x00,0x00,0x00},
							  {"NEG ",0x00,0x00,0x00,0x60,0x70},
							  {"NEGA ",0x00,0x40,0x00,0x00,0x00},
							  {"NEGB ",0x00,0x50,0x00,0x00,0x00},
							  {"NOP ",0x00,0x01,0x00,0x00,0x00},
							  {"LDX ",0x00,0x00,0xce,0xee,0xfe},
							  {"LDS ",0x00,0x00,0x8e,0xae,0xbe},
							  {"LDAA ",0x00,0x00,0x86,0xa6,0xb6},
							  {"LDAB ",0x00,0x00,0xc6,0xe6,0xf6},
							  {"LDD ",0x00,0x00,0xcc,0xec,0xfc},
							  {"LSL ",0x00,0x00,0x00,0x68,0x78},
							  {"LSLA ",0x00,0x48,0x00,0x00,0x00},
							  {"LSLB ",0x00,0x58,0x00,0x00,0x00},
							  {"LSLD ",0x00,0x05,0x00,0x00,0x00},
							  {"LSR ",0x00,0x00,0x00,0x64,0x74},
							  {"LSRA ",0x00,0x44,0x00,0x00,0x00},
							  {"LSRB ",0x00,0x54,0x00,0x00,0x00},
							  {"LSRD ",0x00,0x04,0x00,0x00,0x00},
							  {"ORAA ",0x00,0x00,0x8a,0xaa,0xba},
							  {"ORAB ",0x00,0x00,0xca,0xea,0xfa},
							  {"PSHX ",0x00,0x3c,0x00,0x00,0x00},
							  {"PULX ",0x00,0x38,0x00,0x00,0x00},
							  {"PULA ",0x00,0x32,0x00,0x00,0x00},
							  {"PULB ",0x00,0x33,0x00,0x00,0x00},
							  {"PSHA ",0x00,0x36,0x00,0x00,0x00},
							  {"PSHB ",0x00,0x37,0x00,0x00,0x00},
							  {"ROL ",0x00,0x00,0x00,0x69,0x79},
							  {"ROLA ",0x00,0x49,0x00,0x00,0x00},
							  {"ROLB ",0x00,0x59,0x00,0x00,0x00},
							  {"ROR ",0x00,0x00,0x00,0x66,0x76},
							  {"RORA ",0x00,0x46,0x00,0x00,0x00},
							  {"RORB ",0x00,0x56,0x00,0x00,0x00},
							  {"RTS ",0x00,0x39,0x00,0x00,0x00},
							  {"STX ",0x00,0x00,0x00,0xef,0xff},
							  {"STS ",0x00,0x00,0x00,0xaf,0xbf},
							  {"STAA ",0x00,0x00,0x00,0xa7,0xb7},
							  {"STAB ",0x00,0x00,0x00,0xe7,0xf7},
							  {"STD ",0x00,0x00,0x00,0xed,0xfd},
							  {"SBA ",0x00,0x10,0x00,0x00,0x00},
							  {"SBCA ",0x00,0x00,0x82,0xa2,0xb2},
							  {"SBCB ",0x00,0x00,0xc2,0xe2,0xf2},
							  {"SUBA ",0x00,0x00,0x80,0xa0,0xb0},
							  {"SUBB ",0x00,0x00,0xc0,0xe0,0xf0},
							  {"SUBD ",0x00,0x00,0x83,0xa3,0xb3},
							  {"SWI ",0x00,0x3f,0x00,0x00,0x00},
							  {"SEC ",0x00,0x0d,0x00,0x00,0x00},
							  {"SEI ",0x00,0x0f,0x00,0x00,0x00},
							  {"SEV ",0x00,0x0b,0x00,0x00,0x00},
							  {"TXS ",0x00,0x35,0x00,0x00,0x00},
							  {"TSX ",0x00,0x30,0x00,0x00,0x00},
							  {"TST ",0x00,0x00,0x00,0x6d,0x7d},
							  {"TSTA ",0x00,0x4d,0x00,0x00,0x00},
							  {"TSTB ",0x00,0x5d,0x00,0x00,0x00},
							  {"TAB ",0x00,0x16,0x00,0x00,0x00},
							  {"TAP ",0x00,0x06,0x00,0x00,0x00},
							  {"TBA ",0x00,0x17,0x00,0x00,0x00},
							  {"TPA ",0x00,0x07,0x00,0x00,0x00},
							  {"WAI ",0x00,0x3e,0x00,0x00,0x00}
						 };

main(int argc,char *argv[])
{
	 if(argc <= 1)
		  printf("Formato de entrada:  asm68 <(nombre del archivo).(extencion)>");
	 else
	 {
		  printf("  Assembler para Motorola Evm68701.................Version 1.0\n");
		  printf("  Autor Jose R. Portillo L.                   \n");
		  printf("  Departamento de investigacion y Desarrollo de XXXXXXXXXXXXXX c.a.\n\n\n");
		  analiza_texto_fuente(argv[1]);
	 }
}


//;[]---------------------------------------[];
//;  Procedimiento que reconoce el texto del  ;
//;  programa e identifica el final de este.  ;
//;                                           ;
//;  Entrada: Nombre del archivo fuente.      ;
//;[]---------------------------------------[];
int analiza_texto_fuente(char *nombre)
{
	 char    token[8],direccion[5]={0x00,0x00,0x00,0x00,0x00},
				origen[4]="ORG$",fin[5]="END.$",fila_token[80];
	 int     fila=0,columna=0,indice,pointer,comp_lexico=0,i;
	 FILE    *programa;

	 if(!(programa=fopen(nombre,"r")))
	 {
		  printf("Error de lectura: no es posible leer el archivo");
		  return 1;
	 }
	 else                                       //Reconoce el texto.
		  do
		  {
				do
				{
					 indice = pointer = 0;
					 siguiente_linea(programa,fila_token);
					 indice = 0;
					 while((fila_token[indice] == 0x20) && ((fila_token[indice-1] != 0x0d)&&(fila_token[indice] != 0x0a)))
						  indice++;
					 while((fila_token[indice-1] == 0x0d) && (fila_token[indice] == 0x0a))
					 {
						  indice = 0;
						  siguiente_linea(programa,fila_token);
					 }
					 indice=0;
					 while(fila_token[indice] == ';')
					 {
						  siguiente_linea(programa,fila_token);
						  indice = 0;
					 }
					 while(fila_token[indice] == 0x20)  /*Pasa los espacios en blanco.*/
						  indice++;
					 while((fila_token[indice] != 0x20) && ((fila_token[indice-1] != 0x0d)&&(fila_token[indice] != 0x0a)))
					 {
						  token[pointer] = fila_token[indice];
						  indice++;
						  pointer++;
						  comp_lexico = 1;
					 }
				}while(!comp_lexico);
				token[pointer]='$';
				if(s_comp(token,origen))
				{
					 while((fila_token[indice] == 0x20)&&((fila_token[indice-1] != 0x0d)&&(fila_token[indice] != 0x0a)))
						  ++indice;
					 if((fila_token[indice-1] == 0x0d)&&(fila_token[indice] == 0x0a))
					 {
						  printf("Error en seudo-operador ORG");
						  break;
					 }
					 else
						  if((fila_token[indice] >= 0x30)||(fila_token[indice] <= 39))
						  {
								pointer=0;
								while((fila_token[indice] != 0x20)&&((fila_token[indice-1] != 0x0d)&&(fila_token[indice] != 0x0a)))
								{
									 direccion[pointer]=fila_token[indice];
									 ++indice;
									 ++pointer;
								}
								if(pointer > 3)
									 for(pointer=0;pointer<=3;++pointer)
										  direccion[pointer]=direccion[pointer+1];
								comp_lexico=0;
						  }
				}
				else
					 if(s_comp(token,fin))
					 {
						  printf("Programa ensamblado.");
						  break;
					 }
					 else
					 {
						  fila=0;
						  while(fila <= 118)
						  {
								if(s_comp(token,opcode[fila].nemonico))
									 break;
								++fila;
						  }
						  if(fila <= 118)
						  {
								pointer=0;
								i=20;
								while(opcode[fila].nemonico[pointer] != '$')
									 buffer_programa[0][i]=opcode[fila].nemonico[pointer];
								while(fila_token[indice] == 0x20)
									 ++indice;
								pointer=0;
								while((fila_token[indice] != 0x20)&&((fila_token[indice-1] != 0x0d)&&(fila_token[indice] != 0x0a)))
								{
									 token[pointer]=fila_token[indice];
									 ++indice;
									 ++pointer;
								}
								pointer=0;
								if((token[pointer] == '#')&&(opcode[fila].inmediato != 0x00))
								{
						  }
						  else
						  {
						  }
					 }
		  }while(1);
	 fclose(programa);
	 return 0;
}



siguiente_linea(FILE *programa,char fila_token[80])
{
	 unsigned int i=0;

	 fila_token[i]=getc(programa);
	 while(((fila_token[i-1] != 0x0d)&&(fila_token[i] != 0x0a))&&(fila_token[i] != EOF))
	 {
		  ++i;                               //Lee la siguiente fila texto.
		  fila_token[i]=getc(programa);
	 }
}


int  s_comp(char *a,char *b)
{
	unsigned i = 0;

	while((a[i] != '$') && (b[i] != '$'))
		if(a[i] != b[i])
			return 0;
		else
			i++;
	if((a[i] == '$') && (b[i] == '$'))
		return 1;
	else
		return 0;
}


void ascii_binario(char *ascii)
{
	const  mask = 0xF000;
	unsigned i,
				j,
				sh,
				direccion = 0,
				digito = 0;


	for(i = 0,j = 3;i <= 3;i++,j--)      /*Convierte de Ascii a numero.*/
	{
		for(sh = 1,digito = ((ascii[i] & 0xf0) == 0x40) ? ((ascii[i] & 0x0f) + 0x09) : (ascii[i] & 0x0f);sh <= j*4;sh++,digito <<= 1);
		direccion |= digito;
	}
	direccion += incremento;             /*Incrementa numero de direccion.*/
	for(i = 0,j = 3;i <= 3;i++,j--)      /*Convierte de numero en Ascii.*/
	{
		for(sh = 1,digito = direccion & mask;sh <= j*4;sh++,digito >>= 1);
		mask >>= 4;
		digito = (digito > 0x09) ? ((digito - 0x09) | 0x04) : (digito | 0x03);
		ascii[i] = digito;
	}
}
